題目: https://ctf2025.hitcon.org/dashboard/#19

解答: https://reurl.cc/pY2Ej8

這個程式把你傳來的資料偷偷送到同一台電腦上的某些網路埠（port），如果那個內部服務把你送的資料「原封不動地回傳」，程式會把回傳的內容當作 PHP 程式碼執行。結果只要回傳一段會讀 /flag 的程式碼，就能直接看到 flag（比賽答案）。

為什麼會有問題？（用比喻）

想像有個郵差（程式）把你寫的一張紙轉交給同一棟大樓裡的某間辦公室（內網服務）——如果那間辦公室把紙條直接回寄給郵差，郵差就會當那張紙是「可以執行的命令」，然後去做上面寫的事。問題是郵差完全不檢查紙上寫的是不是安全的命令，直接照做 → 這就很危險！

會發生的事（步驟）

你對網站傳送一行資料（HTTP 請求 body），裡面放一段 JSON（也就是一行文字格式）。

網站會把這一行資料送給本機的一些連續埠（例如從 1000 到 1042）。

如果有其中一個埠上有一個「Echo 服務」（會把收到的內容原樣回傳），那個服務就會把你送的那行資料回傳給網站。

網站收到回傳後把它解析成 JSON，看到 signal == "Arrival" 時，就會拿裡面的 logogram 當作 PHP 程式碼執行（eval()），例如 readfile('/flag');，就會把 flag 顯示出來。

攻擊要點

這個漏洞的關鍵是：「把外面傳進來的東西送進內網，內網把它回傳，然後把回傳直接當程式碼執行」。

怎麼做

下面是最簡單的做法：我們用 curl 傳一行 JSON，內容告訴伺服器「如果你收到回傳就執行讀檔命令」。

URL="http://no-mans-echo.chal.hitconctf.com/index.php"
# 這一行就是我們要送的資料（注意末尾有換行符 \n）
PAYLOAD=$'{"signal":"Arrival","logogram":"readfile(\"/flag\");"}\n'

# 從 1 開始，每次加 43，掃過所有可能的起點
for P in $(seq 1 43 65535); do
  curl -s -X POST "$URL?probe=$P" --data-binary "$PAYLOAD" \
    | grep -E "hitcon\{|flag\{|CTF\{" && echo "Hit at probe=$P" && break
done


解釋：

probe 指定程式要檢查哪一段埠（從 probe 到 probe+42）。

因為程式只讀「一行」，所以我們把整個 JSON 放在同一行，並在最後加 \n。

如果命中，伺服器就會執行 readfile('/flag')，然後回傳 flag，我們就能看到。

因為程式會試 probe 到 probe+42 共 43 個埠，所以只要以步長 43 掃遍所有可能的起點，一定會碰到那個有 echo 的埠。

把一段「會被當作 PHP 執行」的文字送到目標，並嘗試用一種聰明的步長（43）掃遍所有內網埠範圍，搭配多執行緒同時嘗試，快速找出能把我們送去內網並回顯的服務，然後讓伺服器執行 readfile('/flag') 把 flag 印出來。

重要技術點：單行 JSON + 換行（對方用 fgets()）、步長 43（覆蓋 probe..probe+42 區塊）、並行請求（加速）。

為什麼這樣能得到 flag？

伺服器執行了 eval()，也就是「把字串當成程式碼執行」。如果那段字串是讀檔的命令（readfile('/flag');），程式就會把 flag 的內容印出來在網頁回應中。

如何修補／防範

這裡也教你如果是程式設計者，要怎麼避免發生這種事：

不要用 eval() 去執行來自網路或不可信來源的字串。 這是最重要的一條。

如果真的需要「執行命令」，用 白名單：只允許預先定義好的幾個命令對應到固定功能，別把任意字串直接當程式碼。

不要把外部輸入直接轉送給內網任意埠，尤其是讓伺服器去嘗試連很多埠並執行回傳結果的行為。

把敏感檔案（像 /flag）放在只有特定帳號能讀的地方，或讓 web 服務的權限更小（最小權限原則）。

小總結

漏洞：網站把內網回傳的文字當作 PHP 程式碼執行（eval()），而內網服務恰好會回顯我們送的文字 → 可造成遠端執行命令（RCE）。

利用方法：傳送一行 JSON（包含要執行的 PHP）並用步長 43 掃描 probe，命中後 site 就會執行 readfile('/flag') 顯示 flag。

教訓：千萬別把不可信的輸入當成程式碼執行；設計網路程式時要小心把外部輸入「傳到內網」的行為。
