# 題目

[CTF 題目連結](https://ctf2025.hitcon.org/dashboard/#19)

# 後門程式
[程式](https://drive.google.com/file/d/1oa7O-PXgpiHE4vkEgo6qaXa2kF-HIwfb/view?usp=sharing)



[解答連結](https://reurl.cc/pY2Ej8)

# 概述
這是一個潛藏後門程式，它的作用是：

從 URL 取得起始 port（probe），生成一組連續的 TCP port 範圍（共 43 個）。

對本機伺服器的這些 port 進行隨機順序的連線測試（探測）。

一旦某個 port 有回應，且回應內容符合特定格式（JSON 內含 signal: "Arrival"）：

就會執行回應中的 PHP 程式碼（透過 eval()）。

如果沒有成功連上或取得有效回應，就會把自己的程式碼秀出來（highlight_file(__FILE__)）。
--------------------------------------
這個程式會把你傳來的資料偷偷送到同一台電腦上的某些網路埠（port）。如果那個內部服務把你送的資料**原封不動地回傳**，程式會把回傳的內容當作 PHP 程式碼執行。只要回傳一段會讀 `/flag` 的程式碼，就能直接看到 flag（比賽答案）。

# 為什麼會有問題？（比喻）

想像有個郵差（程式）把你寫的一張紙轉交給同一棟大樓裡的某間辦公室（內網服務）。如果那間辦公室把紙條直接回寄給郵差，郵差就會把那張紙當成「可以執行的命令」去做上面寫的事。但郵差完全不檢查紙上寫的是不是安全的命令，直接照做 → 這就很危險！

# 會發生的事（步驟）

1. 你對網站傳送一行資料（HTTP 請求 body），裡面放一段 JSON（即一行文字）。
2. 網站會把這一行資料送給本機的一些連續埠（例如從 1000 到 1042）。
3. 如果其中某個埠有一個「Echo 服務」（會把收到的內容原樣回傳），那個服務會把你送的那行資料回傳給網站。
4. 網站收到回傳後把它解析成 JSON，看到 `signal == "Arrival"` 時，就會拿裡面的 `logogram` 當作 PHP 程式碼執行（`eval()`）。例如 `readfile('/flag');` 就會把 flag 顯示出來。

# 攻擊要點（摘要）

* 把外面傳進來的東西送進內網，內網把它回傳，然後把回傳直接當程式碼執行（RCE 的來源）。
* 關鍵技術點：單行 JSON + 換行（對方用 `fgets()`）、步長 43（覆蓋 `probe..probe+42` 區塊）、並行請求（加速掃描）。

# 怎麼做（範例腳本）

下面是一個最簡單的做法：用 `curl` 傳一行 JSON，內容告訴伺服器「如果你收到回傳就執行讀檔命令」。

```bash
URL="http://no-mans-echo.chal.hitconctf.com/index.php"

# 這一行就是要送的資料（注意末尾有換行符 \n）
PAYLOAD=$'{"signal":"Arrival","logogram":"readfile(\"/flag\");"}\n'

# 從 1 開始，每次加 43，掃過所有可能的起點
for P in $(seq 1 43 65535); do
  curl -s -X POST "$URL?probe=$P" --data-binary "$PAYLOAD" \
    | grep -E "hitcon\{|flag\{|CTF\{" && echo "Hit at probe=$P" && break
done
```

# 程式與參數說明

* `probe`：指定程式要檢查哪一段埠（從 `probe` 到 `probe+42`）。
* 程式只讀「**一行**」，因此整個 JSON 必須放在同一行，並在最後加 `\n`。
* 如果命中，那台伺服器會執行 `readfile('/flag')`，然後把 flag 回傳，我們就能看到。
* 因為程式會嘗試 `probe` 到 `probe+42` 共 43 個埠，所以以步長 43 掃遍所有可能的起點可以保證覆蓋所有埠號。

# 利用策略（說明）

把一段「會被當作 PHP 執行」的文字送到目標，並用步長 43 掃描所有內網埠範圍。搭配多執行緒（並行請求）可以大幅加速，找到那個會回顯我們送入內容的 echo 服務，伺服器接著就會執行 `readfile('/flag')` 並印出 flag。

# 為何能得到 flag？

伺服器使用 `eval()` 把收到的字串當成程式碼執行。如果該字串是 `readfile('/flag');`，就會把 `/flag` 的內容印到網頁回應中。

# 如何修補 / 防範

* **不要使用 `eval()`** 去執行來自網路或不可信來源的字串（最重要）。
* 如果真的需要「執行命令」，採用**白名單**：只允許預先定義好的命令對應到固定功能，不要執行任意字串。
* **不要把外部輸入直接轉送到內網任意埠**，避免伺服器對內網任意埠進行嘗試並執行回傳結果。
* 把敏感檔案（例如 `/flag`）存放在不能被 web 程式讀取的位置，並採取**最小權限原則**（web 服務應有最小讀取權限）。

# 小總結

* 漏洞類型：網站把內網回傳的文字當作 PHP 程式碼執行（`eval()`） → 可造成遠端執行命令（RCE）。
* 利用方法：傳送一行 JSON（包含要執行的 PHP）並用步長 43 掃描 `probe`，命中後 site 就會執行 `readfile('/flag')` 並顯示 flag。
* 教訓：千萬不要把不可信的輸入當成程式碼執行；設計時避免把外部輸入不經處理就傳到內網並執行回傳結果。

# eval() 是什麼（一句話）

`eval()` 是把字串當作程式碼來執行的函式 —— 把文字「翻成程式」並馬上執行。

